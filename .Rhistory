# Put estimated probabilities into long format
dat_long_est <- mod2predict |>
pivot_longer(2:13,
names_to = "outcome_val",
values_to = "pred_prob") |>
select(Sensory, outcome_val, pred_prob)
# Put estimated lower CI into long format
dat_long_lowerci <- mod2predict |>
pivot_longer(14:25,
names_to = "outcome_val",
values_to = "pred_lowerci") |>
select(Sensory, outcome_val, pred_lowerci)
# Put estimated upper CI into long format
dat_long_upperci <- mod2predict |>
pivot_longer(26:37,
names_to = "outcome_val",
values_to = "pred_upperci") |>
select(Sensory, outcome_val, pred_upperci)
# cbind together
dat_long <- cbind(dat_long_est, dat_long_lowerci[3], dat_long_upperci[3])
dat_long <- dat_long |>
mutate(outcome_val = str_sub(outcome_val, 4, -1))
dat_long |>
mutate(outcome_val = str_sub(outcome_val, 4, -1))
dat_long |>
mutate(outcome_val = str_sub(outcome_val, 3, -1))
dat_long |>
mutate(outcome_val = str_sub(outcome_val, 3))
dat_long |>
mutate(outcome_val = str_sub(outcome_val, 3, n()))
dat_long |>
mutate(outcome_val = str_sub(outcome_val, 3, nchar()))
mutate(EDSS = str_sub(outcome_val, 3, -1)
View(dat_long)
View(dat_long)
newdat <- data.frame(Sensory = c(0, 1)) |>
mutate(Sensory = factor(Sensory))
# Predict on the linear (log-odds) scale
mod2predict  <- cbind(newdat, predict(mod2, newdat, interval = T, type = "prob"))
mod2predict
# Put estimated probabilities into long format
dat_long_est <- mod2predict |>
pivot_longer(2:13,
names_to = "outcome_val",
values_to = "pred_prob") |>
select(Sensory, outcome_val, pred_prob)
# Put estimated lower CI into long format
dat_long_lowerci <- mod2predict |>
pivot_longer(14:25,
names_to = "outcome_val",
values_to = "pred_lowerci") |>
select(Sensory, outcome_val, pred_lowerci)
# Put estimated upper CI into long format
dat_long_upperci <- mod2predict |>
pivot_longer(26:37,
names_to = "outcome_val",
values_to = "pred_upperci") |>
select(Sensory, outcome_val, pred_upperci)
# cbind together
dat_long <- cbind(dat_long_est, dat_long_lowerci[3], dat_long_upperci[3])
dat_long <- dat_long |>
mutate(EDSS = str_sub(outcome_val, 3, -1))
View(dat_long)
newdat <- data.frame(Sensory = c(0, 1)) |>
mutate(Sensory = factor(Sensory))
# Predict on the linear (log-odds) scale
mod2predict  <- cbind(newdat, predict(mod2, newdat, interval = T, type = "prob"))
mod2predict
# Put estimated probabilities into long format
dat_long_est <- mod2predict |>
pivot_longer(2:13,
names_to = "outcome_val",
values_to = "pred_prob") |>
select(Sensory, outcome_val, pred_prob)
# Put estimated lower CI into long format
dat_long_lowerci <- mod2predict |>
pivot_longer(14:25,
names_to = "outcome_val",
values_to = "pred_lowerci") |>
select(Sensory, outcome_val, pred_lowerci)
# Put estimated upper CI into long format
dat_long_upperci <- mod2predict |>
pivot_longer(26:37,
names_to = "outcome_val",
values_to = "pred_upperci") |>
select(Sensory, outcome_val, pred_upperci)
# cbind together
dat_long <- cbind(dat_long_est, dat_long_lowerci[3], dat_long_upperci[3])
dat_long <- dat_long |>
mutate(EDSS = str_sub(outcome_val, 4, -1))
View(dat_long)
# Create new dataframe to predict on
newdat <- data.frame(Sensory = c(0, 1)) |>
mutate(Sensory = factor(Sensory))
# Predict on the linear (log-odds) scale
mod2predict  <- cbind(newdat, predict(mod2, newdat, interval = T, type = "prob"))
mod2predict
# Put estimated probabilities into long format
dat_long_est <- mod2predict |>
pivot_longer(2:13,
names_to = "outcome_val",
values_to = "pred_prob") |>
select(Sensory, outcome_val, pred_prob)
# Put estimated lower CI into long format
dat_long_lowerci <- mod2predict |>
pivot_longer(14:25,
names_to = "outcome_val",
values_to = "pred_lowerci") |>
select(Sensory, outcome_val, pred_lowerci)
# Put estimated upper CI into long format
dat_long_upperci <- mod2predict |>
pivot_longer(26:37,
names_to = "outcome_val",
values_to = "pred_upperci") |>
select(Sensory, outcome_val, pred_upperci)
# cbind together
dat_long <- cbind(dat_long_est, dat_long_lowerci[3], dat_long_upperci[3])
dat_long <- dat_long |>
mutate(EDSS = str_sub(outcome_val, 5, -1))
View(dat_long)
newdat <- data.frame(Sensory = c(0, 1)) |>
mutate(Sensory = factor(Sensory))
# Predict on the linear (log-odds) scale
mod2predict  <- cbind(newdat, predict(mod2, newdat, interval = T, type = "prob"))
mod2predict
# Put estimated probabilities into long format
dat_long_est <- mod2predict |>
pivot_longer(2:13,
names_to = "outcome_val",
values_to = "pred_prob") |>
select(Sensory, outcome_val, pred_prob)
# Put estimated lower CI into long format
dat_long_lowerci <- mod2predict |>
pivot_longer(14:25,
names_to = "outcome_val",
values_to = "pred_lowerci") |>
select(Sensory, outcome_val, pred_lowerci)
# Put estimated upper CI into long format
dat_long_upperci <- mod2predict |>
pivot_longer(26:37,
names_to = "outcome_val",
values_to = "pred_upperci") |>
select(Sensory, outcome_val, pred_upperci)
# cbind together
dat_long <- cbind(dat_long_est, dat_long_lowerci[3], dat_long_upperci[3])
dat_long <- dat_long |>
mutate(EDSS = as.numeric(str_sub(outcome_val, 5, -1)))
# Plot
ggplot(dat_long, aes(x = outcome_val, y = pred_prob)) +
geom_point(aes(color = Sensory), position = position_dodge(width = 0.5)) +
geom_errorbar(aes(ymin = pred_lowerci, ymax = pred_upperci, color = Sensory), position = position_dodge(width = 0.5), width = 0.3) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.1)) +
scale_color_manual(values = c("#E69F00", "#56B4E9")) +
xlab("EDSS") + ylab("Predicted Probability") +
theme_bw(base_size = 20)
# Plot
ggplot(dat_long, aes(x = EDSS, y = pred_prob)) +
geom_point(aes(color = Sensory), position = position_dodge(width = 0.5)) +
geom_errorbar(aes(ymin = pred_lowerci, ymax = pred_upperci, color = Sensory), position = position_dodge(width = 0.5), width = 0.3) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.1)) +
scale_color_manual(values = c("#E69F00", "#56B4E9")) +
xlab("EDSS") + ylab("Predicted Probability") +
theme_bw(base_size = 20)
dat$EDSS
# Plot
ggplot(dat_long, aes(x = EDSS, y = pred_prob)) +
geom_point(aes(color = Sensory), position = position_dodge(width = 0.5)) +
geom_errorbar(aes(ymin = pred_lowerci, ymax = pred_upperci, color = Sensory), position = position_dodge(width = 0.5), width = 0.3) +
scale_x_continuous(limits = c(0, 6), breaks = seq(0, 6, by = 0.5)) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.1)) +
scale_color_manual(values = c("#E69F00", "#56B4E9")) +
xlab("EDSS") + ylab("Predicted Probability") +
theme_bw(base_size = 20)
#| label: load data
#| include: false
dat <- read.csv("/Users/paulsanfilippo/Dropbox/Alfred Neuroscience/zz_test_site/posts/011_03May_2024/Supplementary Table 1 for patient info .csv", header = T)
#| label: data
head(dat, 10)
#| label: boxplot
#| warning: false
library(ggplot2)
library(tidyverse)
library(gtsummary)
library(ordinal)
library(ggeffects)
ggplot(dat, aes(x = factor(Sensory), y = EDSS)) +
geom_boxplot() +
geom_dotplot(binaxis = 'y', stackdir = 'center', position = position_dodge(1), dotsize = 0.8) +
xlab("Sensory Symptoms") +
theme_bw(base_size = 20)
#| label: lm
#| warning: false
mod1 <- lm(EDSS ~ Sensory, data = dat)
mod1 |> tbl_regression(intercept = T)
#| label: clm
#| warning: false
dat$EDSS <- factor(dat$EDSS) # format EDSS as factor
mod2 <- clm(EDSS ~ factor(Sensory), data = dat, link = "logit")
mod2 |> tbl_regression(exponentiate = T, intercept = T)
#| label: propodds
#| warning: false
library(gofcat)
brant.test(mod2)
#| label: predict
#| warning: false
# Create new dataframe to predict on
newdat <- data.frame(Sensory = c(0, 1)) |>
mutate(Sensory = factor(Sensory))
# Predict on the linear (log-odds) scale
mod2predict  <- cbind(newdat, predict(mod2, newdat, interval = T, type = "prob"))
mod2predict
# Put estimated probabilities into long format
dat_long_est <- mod2predict |>
pivot_longer(2:13,
names_to = "outcome_val",
values_to = "pred_prob") |>
select(Sensory, outcome_val, pred_prob)
# Put estimated lower CI into long format
dat_long_lowerci <- mod2predict |>
pivot_longer(14:25,
names_to = "outcome_val",
values_to = "pred_lowerci") |>
select(Sensory, outcome_val, pred_lowerci)
# Put estimated upper CI into long format
dat_long_upperci <- mod2predict |>
pivot_longer(26:37,
names_to = "outcome_val",
values_to = "pred_upperci") |>
select(Sensory, outcome_val, pred_upperci)
# cbind together
dat_long <- cbind(dat_long_est, dat_long_lowerci[3], dat_long_upperci[3])
dat_long <- dat_long |>
mutate(EDSS = as.numeric(str_sub(outcome_val, 5, -1)))
# Plot
ggplot(dat_long, aes(x = EDSS, y = pred_prob)) +
geom_point(aes(color = Sensory), position = position_dodge(width = 0.5)) +
geom_errorbar(aes(ymin = pred_lowerci, ymax = pred_upperci, color = Sensory), position = position_dodge(width = 0.5), width = 0.3) +
scale_x_continuous(limits = c(0, 6), breaks = seq(0, 6, by = 0.5)) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.1)) +
scale_color_manual(values = c("#E69F00", "#56B4E9")) +
xlab("EDSS") + ylab("Predicted Probability") +
theme_bw(base_size = 20)
#| label: load data
#| include: false
dat <- read.csv("/Users/paulsanfilippo/Dropbox/Alfred Neuroscience/zz_test_site/posts/011_03May_2024/Supplementary Table 1 for patient info .csv", header = T)
#| label: data
head(dat, 10)
#| label: boxplot
#| warning: false
library(ggplot2)
library(tidyverse)
library(gtsummary)
library(ordinal)
library(ggeffects)
ggplot(dat, aes(x = factor(Sensory), y = EDSS)) +
geom_boxplot() +
geom_dotplot(binaxis = 'y', stackdir = 'center', position = position_dodge(1), dotsize = 0.8) +
xlab("Sensory Symptoms") +
theme_bw(base_size = 20)
#| label: lm
#| warning: false
mod1 <- lm(EDSS ~ Sensory, data = dat)
mod1 |> tbl_regression(intercept = T)
#| label: clm
#| warning: false
dat$EDSS <- factor(dat$EDSS) # format EDSS as factor
mod2 <- clm(EDSS ~ factor(Sensory), data = dat, link = "logit")
mod2 |> tbl_regression(exponentiate = T, intercept = T)
#| label: propodds
#| warning: false
library(gofcat)
brant.test(mod2)
#| label: predict
#| warning: false
# Create new dataframe to predict on
newdat <- data.frame(Sensory = c(0, 1)) |>
mutate(Sensory = factor(Sensory))
# Predict on the linear (log-odds) scale
mod2predict  <- cbind(newdat, predict(mod2, newdat, interval = T, type = "prob"))
# Put estimated probabilities into long format
dat_long_est <- mod2predict |>
pivot_longer(2:13,
names_to = "outcome_val",
values_to = "pred_prob") |>
select(Sensory, outcome_val, pred_prob)
# Put estimated lower CI into long format
dat_long_lowerci <- mod2predict |>
pivot_longer(14:25,
names_to = "outcome_val",
values_to = "pred_lowerci") |>
select(Sensory, outcome_val, pred_lowerci)
# Put estimated upper CI into long format
dat_long_upperci <- mod2predict |>
pivot_longer(26:37,
names_to = "outcome_val",
values_to = "pred_upperci") |>
select(Sensory, outcome_val, pred_upperci)
# cbind together
dat_long <- cbind(dat_long_est, dat_long_lowerci[3], dat_long_upperci[3])
# Create EDSS variable from outcome_val
dat_long <- dat_long |>
mutate(EDSS = as.numeric(str_sub(outcome_val, 5, -1)))
# Plot
ggplot(dat_long, aes(x = EDSS, y = pred_prob)) +
geom_point(aes(color = Sensory), position = position_dodge(width = 0.5)) +
geom_errorbar(aes(ymin = pred_lowerci, ymax = pred_upperci, color = Sensory), position = position_dodge(width = 0.2), width = 0.5) +
scale_x_continuous(limits = c(0, 6), breaks = seq(0, 6, by = 0.5)) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.1)) +
scale_color_manual(values = c("#E69F00", "#56B4E9")) +
xlab("EDSS") + ylab("Predicted Probability") +
theme_bw(base_size = 20)
# Plot
ggplot(dat_long, aes(x = EDSS, y = pred_prob)) +
geom_point(aes(color = Sensory), position = position_dodge(width = 0.2)) +
geom_errorbar(aes(ymin = pred_lowerci, ymax = pred_upperci, color = Sensory), position = position_dodge(width = 0.2), width = 0.5) +
scale_x_continuous(limits = c(0, 6), breaks = seq(0, 6, by = 0.5)) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.1)) +
scale_color_manual(values = c("#E69F00", "#56B4E9")) +
xlab("EDSS") + ylab("Predicted Probability") +
theme_bw(base_size = 20)
warnings()
warnings()
n <- 1000                                          # set number of obs to simulate
set.seed(1234)                                     # set seed for reproducibility
mac_hole_size  <-  rnorm(n, 486, 142)              # generate macular hole inner opening data with mean 486 and sd = 152
logodds_success  <-  10.89 - 0.016 * mac_hole_size # generate variable that is linear combination of intercept = 10.89 and coefficient for macular hole -0.016 (logit scale)
odds_success  <-  exp(logodds_success)             # exponentiate logodds to get odds
prob_success  <-  odds_success/(1 + odds_success)  # generate probabilities from this
y_success  <-  rbinom(n, 1, prob_success)          # generate outcome variable as a function of those probabilities
df <-  data.frame(cbind(mac_hole_size,             # combine into dataframe
logodds_success,
odds_success,
prob_success,
y_success))
df <- df |>
filter(mac_hole_size > 100)                       # only include those with size > 100
head(df, 20)
n <- 1000                                          # set number of obs to simulate
set.seed(1234)                                     # set seed for reproducibility
mac_hole_size  <-  rnorm(n, 486, 142)              # generate macular hole inner opening data with mean 486 and sd = 152
logodds_success  <-  10.89 - 0.016 * mac_hole_size # generate variable that is linear combination of intercept = 10.89 and coefficient for macular hole -0.016 (logit scale)
odds_success  <-  exp(logodds_success)             # exponentiate logodds to get odds
prob_success  <-  odds_success/(1 + odds_success)  # generate probabilities from this
y_success  <-  rbinom(n, 1, prob_success)          # generate outcome variable as a function of those probabilities
df <-  data.frame(cbind(mac_hole_size,             # combine into dataframe
logodds_success,
odds_success,
prob_success,
y_success))
df <- df |>
filter(mac_hole_size > 100)                       # only include those with size > 100
head(df)
mac_hole_size
logodds_success
y_success
data.frame(cbind(mac_hole_size,             # combine into dataframe
logodds_success,
odds_success,
prob_success,
y_success))
df <-  data.frame(cbind(mac_hole_size,             # combine into dataframe
logodds_success,
odds_success,
prob_success,
y_success))
head(df)
df <- df |>
filter(mac_hole_size > 100)                       # only include those with size > 100
head(df)
n <- 1000                                          # set number of obs to simulate
set.seed(1234)                                     # set seed for reproducibility
mac_hole_size  <-  rnorm(n, 486, 142)              # generate macular hole inner opening data with mean 486 and sd = 152
logodds_success  <-  10.89 - 0.016 * mac_hole_size # generate variable that is linear combination of intercept = 10.89 and coefficient for macular hole -0.016 (logit scale)
odds_success  <-  exp(logodds_success)             # exponentiate logodds to get odds
prob_success  <-  odds_success/(1 + odds_success)  # generate probabilities from this
y_success  <-  rbinom(n, 1, prob_success)          # generate outcome variable as a function of those probabilities
df <-  data.frame(cbind(mac_hole_size,             # combine into dataframe
logodds_success,
odds_success,
prob_success,
y_success))
head(df)
df |>
filter(mac_hole_size > 100)
str(df)
df |>
filter(mac_hole_size > 100)
library(tidyverse)
n <- 1000                                          # set number of obs to simulate
set.seed(1234)                                     # set seed for reproducibility
mac_hole_size  <-  rnorm(n, 486, 142)              # generate macular hole inner opening data with mean 486 and sd = 152
logodds_success  <-  10.89 - 0.016 * mac_hole_size # generate variable that is linear combination of intercept = 10.89 and coefficient for macular hole -0.016 (logit scale)
odds_success  <-  exp(logodds_success)             # exponentiate logodds to get odds
prob_success  <-  odds_success/(1 + odds_success)  # generate probabilities from this
y_success  <-  rbinom(n, 1, prob_success)          # generate outcome variable as a function of those probabilities
df <-  data.frame(cbind(mac_hole_size,             # combine into dataframe
logodds_success,
odds_success,
prob_success,
y_success))
df <- df |>
filter(mac_hole_size > 100)                       # only include those with size > 100
head(df)
head(df, 20) |> kable(booktabs = T) %>%
kable_styling() %>%
row_spec(5, bold = T, color = "white", background = "red")
library(kableExtra)
head(df, 20) |> kable(booktabs = T) %>%
kable_styling() %>%
row_spec(5, bold = T, color = "white", background = "red")
head(df, 20) |>
kable() |>
kable_styling() |>
row_spec(5, bold = T, color = "white", background = "red") |>
row_spec(10, bold = T, color = "white", background = "green")
head(df, 20) |>
kable() |>
kable_styling() |>
row_spec(1, bold = T, background = "skyblue1") |>
row_spec(10, bold = T, color = "white", background = "green")
head(df, 20) |>
kable() |>
kable_styling() |>
row_spec(1, bold = T, background = "skyblue1") |>
row_spec(20, bold = T, color = "white", background = "lightgoldenrod1")
# Linear model
mod_linear <- lm(y_success ~ I(mac_hole_size/100), data = df)
mod_linear |>
tbl_regression(intercept = T)
library(gtsummary)
# Linear model
mod_linear <- lm(y_success ~ I(mac_hole_size/100), data = df)
mod_linear |>
tbl_regression(intercept = T)
# Plot data with regression line
ggplot(df, aes(mac_hole_size, y_success)) +
geom_point(size = 2, alpha = 0.1) +
geom_abline(slope = coef(mod_linear)[["I(mac_hole_size/100)"]]/100,
intercept = coef(mod_linear)[["(Intercept)"]],
color = "cornflowerblue", linewidth = 1) +
scale_x_continuous(limits = c(0, 1200), breaks = seq(0, 1200, by = 100)) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 1)) +
xlab("Macular hole size") + ylab("Surgical repair success") +
theme_bw(base_size = 20)
# Create new df to predict on new values of x
new_dat <- data.frame(mac_hole_size = seq(from = 0, to = 1200, by = 50))
# Predict new fitted values
pred <- cbind(new_dat, prediction = predict(mod_linear, newdata = new_dat))
# Display predictions
head(pred, 20) |>
kable() |>
kable_styling() |>
row_spec(1, bold = T, background = "skyblue1") |>
row_spec(20, bold = T, background = "lightgoldenrod1")
# Create new df to predict on new values of x
new_dat <- data.frame(mac_hole_size = seq(from = 0, to = 1200, by = 50))
# Predict new fitted values
pred <- cbind(new_dat, prediction = predict(mod_linear, newdata = new_dat))
# Display predictions
pred |>
kable() |>
kable_styling() |>
row_spec(1, bold = T, background = "skyblue1") |>
row_spec(20, bold = T, background = "lightgoldenrod1")
# Create new df to predict on new values of x
new_dat <- data.frame(mac_hole_size = seq(from = 0, to = 1200, by = 50))
# Predict new fitted values
pred <- cbind(new_dat, prediction = predict(mod_linear, newdata = new_dat))
# Display predictions
pred |>
kable() |>
kable_styling() |>
row_spec(1, bold = T, background = "skyblue1") |>
row_spec(25, bold = T, background = "lightgoldenrod1")
#| tbl-colwidths: auto
# Create new df to predict on new values of x
new_dat <- data.frame(mac_hole_size = seq(from = 0, to = 1200, by = 50))
# Predict new fitted values
pred <- cbind(new_dat, prediction = predict(mod_linear, newdata = new_dat))
# Display predictions
pred |>
kable() |>
kable_styling() |>
row_spec(3, bold = T, background = "skyblue1") |>
row_spec(25, bold = T, background = "lightgoldenrod1")
#| tbl-colwidths: [20,20]
# Create new df to predict on new values of x
new_dat <- data.frame(mac_hole_size = seq(from = 0, to = 1200, by = 50))
# Predict new fitted values
pred <- cbind(new_dat, prediction = predict(mod_linear, newdata = new_dat))
# Display predictions
pred |>
kable() |>
kable_styling() |>
row_spec(3, bold = T, background = "skyblue1") |>
row_spec(25, bold = T, background = "lightgoldenrod1")
# Create new df to predict on new values of x
new_dat <- data.frame(mac_hole_size = seq(from = 0, to = 1200, by = 50))
# Predict new fitted values
pred <- cbind(new_dat, prediction = predict(mod_linear, newdata = new_dat))
# Display predictions
pred |>
kable(align = "c") |>
kable_styling() |>
row_spec(3, bold = T, background = "skyblue1") |>
row_spec(25, bold = T, background = "lightgoldenrod1")
head(df, 20) |>
kable(align = "c", digits = 2) |>
kable_styling() |>
row_spec(1, bold = T, background = "skyblue1") |>
row_spec(20, bold = T, background = "lightgoldenrod1")
exp(-1.5)
