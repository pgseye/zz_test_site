{
  "hash": "1496277ef34bfe500f481ec85dbb3bda",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"janitor - Your local R handypackage\"\ndate: 2025-03-07\ncategories: [code]\nimage: \"R_small.jpeg\"\ndescription: \"Work smarter, not harder.\"\nformat: \n   html:\n     df-print: tibble\n---\n\n\n\nA (fairly) short post today. I want to introduce you to a great little `R` package that I load in every one of my scripts, because I never know when I might need to use it. `janitor` contains several functions, but there are two primary ones that I want to draw your attention to - `clean_names` and `tabyl`.\n\n# clean_names()\n\nIf you have control over the names of the variables in your dataset, can I please implore you to adopt one of the two recommended naming conventions - **camelCase** or **snake_case**. I prefer the latter for its readability, so I would suggest that one if you don't have a preference. A somewhat frustrating (and completely avoidable) issue that I sometimes have to deal with when being sent a dataset, is to spend time renaming variables. White spaces in variable names are by biggest bugbear, but the inclusion of symbols, the capitalisation of some letters, and the use of repeated identical names, follow closely behind. `R` doesn't like any of this.\n\nIf proactive measures aren't possible, we can use `clean_names` in a reactive manner. I will use the same example provided by the package author in their [vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#clean-dataframe-names-with-clean_names) to illustrate how useful `clean_names` can be. Let's say we receive a spreadsheet that we import into our `R` workspace with the following column names:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(janitor)\n# Create a data.frame with dirty names\ntest_df <- as.data.frame(matrix(ncol = 6))\nnames(test_df) <- c(\"firstName\", \"ábc@!*\", \"% successful (2009)\",\n                    \"REPEAT VALUE\", \"REPEAT VALUE\", \"\")\nnames(test_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"firstName\"           \"ábc@!*\"              \"% successful (2009)\"\n[4] \"REPEAT VALUE\"        \"REPEAT VALUE\"        \"\"                   \n```\n\n\n:::\n:::\n\n\n\nHorrible!\n\nFixing this, however, is as simple as running `clean_names` (snake_case is the default) on the dataframe:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_df <-  clean_names(test_df)\nnames(test_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"first_name\"              \"abc\"                    \n[3] \"percent_successful_2009\" \"repeat_value\"           \n[5] \"repeat_value_2\"          \"x\"                      \n```\n\n\n:::\n:::\n\n\n\nBeautiful!\n\nThere is some customisation available within the function and I would encourage you to check that out too.\n\n# tabyl()\n\n`R`'s base `table()` command gets the job done, but I dare anyone to say it does it nicely. Having some experience with `Stata`, its equivalent `tabulate` command provides the readability/presentability luxury of a Rolls-Royce compared to `table()`'s cramped and bland version of a Datsun Sunny 120Y (the car my good friend drove us around in while we were at Uni BTW - as I said, it gets the job done!)\n\nLet me give you an example. We'll use the Star Wars dataset that comes with the `dplyr` package. We're interested in first tabulating the categories of **eye colour** in humans, and then after that, cross-tabulating **eye-colour** with **gender**.\n\n## One-way Tabulation\n\nBase `R`'s tabulation of **eye-colour** gives:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load data\nhumans <- starwars |> \n  filter(species == \"Human\")\n# Base R table\ntable(humans$eye_color)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     blue blue-gray     brown      dark     hazel   unknown    yellow \n       12         1        16         1         2         1         2 \n```\n\n\n:::\n:::\n\n\n\nYou can imagine that with a factor that contains more categories, the listing starts to spill out over another row (sometimes more) in your console. It's just not pleasant to quickly look at and interpret. In comparison, in its most basic call, `tabyl()` gives:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhumans |> \n  tabyl(eye_color, show_na = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 3\n  eye_color     n percent\n  <chr>     <int>   <dbl>\n1 blue         12  0.343 \n2 blue-gray     1  0.0286\n3 brown        16  0.457 \n4 dark          1  0.0286\n5 hazel         2  0.0571\n6 unknown       1  0.0286\n7 yellow        2  0.0571\n```\n\n\n:::\n:::\n\n\n\nIt prints in a much more readable column format, and provides percentages, as well as frequencies, by default.\n\nTo save keystrokes, I have written a function for myself with a few further embellishments - marginal totals as well as makeshift borders (note you will need to have installed the `knitr` package if you want to use this). My aim with this and the subsequent function I am going to share with you was to emulate `Stata`'s `tabulate` command as much as possible.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab1 <- function(df = dat, var, show.miss = T) {\n  df |> \n    tabyl({{var}}, show_na = show.miss) |> \n    adorn_totals(\"row\") |> \n    adorn_pct_formatting(rounding = \"half up\", digits = 2) |> \n    knitr::kable()\n}\n```\n:::\n\n\n\nThen, with a simple `tab1(humans, eye_color, show.miss = T)` I can get:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab1(humans, eye_color, T)\n```\n:::\n\n\n\n![](images/tab1.png){fig-align=\"left\" height=\"230\"}\n\nThe `show.miss = T` will include any missing data as a separate category. You can set this to `F` if you prefer.\n\n## Two-way Tabulation\n\nLet's extend the example further by now cross-tabulating **eye-colour** with **gender**. The Base `R` version gives:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(humans$eye_color, humans$gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           \n            feminine masculine\n  blue             3         9\n  blue-gray        0         1\n  brown            4        12\n  dark             0         1\n  hazel            1         1\n  unknown          1         0\n  yellow           0         2\n```\n\n\n:::\n:::\n\n\n\nThis is actually more readable than the one-way tabulation. In comparison, `tabyl()` produces:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhumans |>\n  tabyl(eye_color, gender, show_na = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 3\n  eye_color feminine masculine\n  <chr>        <dbl>     <dbl>\n1 blue             3         9\n2 blue-gray        0         1\n3 brown            4        12\n4 dark             0         1\n5 hazel            1         1\n6 unknown          1         0\n7 yellow           0         2\n```\n\n\n:::\n:::\n\n\n\nIn its default state, not that different I agree. However, to save some time, and also include a couple of useful additional summaries, I have written myself a function for cross-tabulations as well. Again, I have customised this to my liking, by including marginal totals and bordering. Note that as I have specified row percentages, the marginal row totals all add up to `100%`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab2 <- function(df = dat, var1, var2, show.miss = T) {\n  df |>\n    tabyl({{var1}}, {{var2}}, show_na = show.miss) |>\n    adorn_totals(\"row\") |>\n    adorn_totals(\"col\") |>\n    adorn_percentages(\"row\") |>\n    adorn_pct_formatting(rounding = \"half up\", digits = 2) |>\n    adorn_ns() |>\n    knitr::kable()\n}\n```\n:::\n\n\n\nNow I simply type `tab2(humans, eye_color, gender, show.miss = T)` to get:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab2(humans, eye_color, gender, show.miss = T)\n```\n:::\n\n\n\n![](images/tab2.png){fig-align=\"left\" height=\"230\"}\n\nI better stop there. How is it that my 'short' posts even somehow become long? Until next time...\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}