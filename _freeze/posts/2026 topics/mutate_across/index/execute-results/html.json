{
  "hash": "e496916f48cdb478808e590d2c27f853",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"More DRY (Don't Repeat Yourself) — Meet `mutate(across())`\"\ndate: 2026-01-30\ncategories: [code, concept]\nimage: \"R_small.jpeg\"\ndescription: \"Create or edit multiple columns efficiently.\"\n---\n\n\n\n\n## Introduction\n\nWelcome back to Stats Tips for 2026. I hope you all had a restful break during the holiday period. I spent a couple of weeks on the South Island of New Zealand and was rather in awe of how beautiful that part of the world is - Queenstown, Milford Sound, Lake Tekapo and a 3 day hike on the Humpridge Track, which I can really recommend if you're into hiking. The landscapes are otherworldly - we plan to go back, it was that good...\n\nOk, enough about my holidays and on to more serious topics. Today I thought I would ease you back into the world of statistical musings with a less theoretical and more practical post. One that illustrates the application of what I consider to be an indispensable `dplyr` function in my day-to-day work, and one that I hope you can make use of too - meet `across()`.\n\nI believe one aspiration we all share in our endeavour to become better R programmers is to write more efficient code that avoids *repetition*. You may recall that I have dedicated a whole other [post](https://msni-stats-tips.netlify.app/posts/022_15nov_2024/) to this topic and so our discussion here will further expound upon that theme.\n\nHow many of you have written a block of code that you have just reused, for example:\n\nThe same data transformation copied and pasted five times.\\\nThe same rounding applied column by column.\\\nThe same `ifelse()` rewritten with only the variable name changed.\n\nI know I have.\n\nIn its most fundamental use-case, `across()` makes it easy to apply the same transformation to multiple columns in a dataframe in one go, rather than applying the same code block multiple times. It may not be flashy, but once you get the hang of how it works, your code will become **shorter, clearer, and far easier to maintain**. It's important to note that `across()` doesn't work by itself, but rather is a *column-selection helper* that is evaluated within other `dplyr` functions, most commonly `mutate()`, but also `summarise()` and `filter()`. In this mental model, `mutate()` decides **what happens** and `across()` decides **where is happens**.\n\nLet's make these ideas clearer with several examples...\n\n------------------------------------------------------------------------\n\n## The Problem: Repeating the Same Operation\n\nSuppose you’re analysing a simple dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(id = as.character(1:3),\n             age = c(34, 51, 63),\n             weight = c(72.46, 81.27, 76.85),\n             bmi = c(23.66, 27.93, 26.35),\n             cholesterol = c(5.42, 6.01, 5.87))\n\ndf\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|   bmi| cholesterol|\n|:--|---:|------:|-----:|-----------:|\n|1  |  34|  72.46| 23.66|        5.42|\n|2  |  51|  81.27| 27.93|        6.01|\n|3  |  63|  76.85| 26.35|        5.87|\n\n</div>\n:::\n:::\n\n\n<br>\n\nYou decide that, for reporting, several variables should be rounded to **`1` decimal place**.\n\n------------------------------------------------------------------------\n\n## The Naïve Way\n\nA common first attempt looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(weight = round(weight, 1),\n         bmi = round(bmi, 1),\n         cholesterol = round(cholesterol, 1))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|  bmi| cholesterol|\n|:--|---:|------:|----:|-----------:|\n|1  |  34|   72.5| 23.7|         5.4|\n|2  |  51|   81.3| 27.9|         6.0|\n|3  |  63|   76.8| 26.4|         5.9|\n\n</div>\n:::\n:::\n\n\n<br>\n\nYou write out the same line of code for each variable. It does work. It’s also:\n\n-   Repetitive\\\n-   Error-prone (easy to forget a variable)\\\n-   Painful to update when the variable list changes\n\nIf you later add another variable (say `waist`), you must remember to update this block manually — and everywhere else you did something similar.\n\n------------------------------------------------------------------------\n\n## The Core Idea Behind `across()`\n\nThe key insight is simple:\n\n> **When you apply the same transformation to multiple columns, you should write the transformation once.**\n\nThat’s exactly what `across()` does.\n\n------------------------------------------------------------------------\n\n## The Better Way: `mutate(across())`\n\nHere’s the same transformation rewritten using `across()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(across(c(weight, bmi, cholesterol), round, 1))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|  bmi| cholesterol|\n|:--|---:|------:|----:|-----------:|\n|1  |  34|   72.5| 23.7|         5.4|\n|2  |  51|   81.3| 27.9|         6.0|\n|3  |  63|   76.8| 26.4|         5.9|\n\n</div>\n:::\n:::\n\n\n<br>\n\nRead this out loud:\n\n> “Mutate across weight, bmi, and cholesterol by rounding to 1 decimal place.”\n\nThat phrasing is much closer to how you *think* about the task.\n\n------------------------------------------------------------------------\n\n## Why This Is Better (Beyond Being Shorter)\n\n### It Scales Naturally\n\nIf you add another variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \nmutate(across(c(weight, bmi, cholesterol, waist), round, 1))\n```\n:::\n\n\nNo duplication. No copy-paste.\n\n------------------------------------------------------------------------\n\n### You Can Select Variables Programmatically\n\nInstead of naming variables explicitly, you can select them based on some other programmatic characteristic. Here, let's select all numeric variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(across(where(is.numeric), round, 1))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|  bmi| cholesterol|\n|:--|---:|------:|----:|-----------:|\n|1  |  34|   72.5| 23.7|         5.4|\n|2  |  51|   81.3| 27.9|         6.0|\n|3  |  63|   76.8| 26.4|         5.9|\n\n</div>\n:::\n:::\n\n\n<br>\n\nAlternatively, you might want to select based on naming conventions. In this example, we would select all variables in the dataframe that begin with the text \"lab\\_\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(across(starts_with(\"lab_\"), log))\n```\n:::\n\n\nThis is particularly powerful in real research datasets, where variable names often follow patterns.\n\n------------------------------------------------------------------------\n\n### It Reduces Cognitive Load\n\nIf you reviewed your code 6 months down the track and compared these two blocks:\n\n``` r\nweight = round(weight, 1)\nbmi = round(bmi, 1)\ncholesterol = round(cholesterol, 1)\n```\n\nvs:\n\n``` r\nacross(c(weight, bmi, cholesterol), round, 1)\n```\n\nThe second tells you *what is happening* immediately.\n\n------------------------------------------------------------------------\n\n## Using Anonymous Functions for More Complex Logic\n\nYou’re not limited to simple functions like `round()` - you can write your own. In this case, `across()` recognises everything after the `~` as a user-defined or \"anonymous\" function. For example,\n\nSuppose you want to:\n\n-   add `1` to avoid zeros\\\n-   log-transform the result\\\n-   apply this consistently to multiple variables that begin with \"lab\\_\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(across(starts_with(\"lab_\"), ~ log(.x + 1)))\n```\n:::\n\n\nHere, `.x` represents the current column being transformed.\n\nAs you can see - we can do all of this in one line of code.\n\n------------------------------------------------------------------------\n\n## Creating New Variables Instead of Overwriting\n\nIn research workflows, it’s often good practice for reproducibility to keep raw variables intact and create new variables instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(across(c(weight, bmi), scale, .names = \"{.col}_z\"))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|   bmi| cholesterol|     weight_z|      bmi_z|\n|:--|---:|------:|-----:|-----------:|------------:|----------:|\n|1  |  34|  72.46| 23.66|        5.42| -0.998862996| -1.0746155|\n|2  |  51|  81.27| 27.93|        6.01|  1.001133139|  0.9032328|\n|3  |  63|  76.85| 26.35|        5.87| -0.002270143|  0.1713826|\n\n</div>\n:::\n:::\n\n\n<br>\n\nThis produces new variables (`weight_z`, `bmi_z`) which are the Z-score transformations of `weight` and `bmi` using `R`'s built-in `scale` function. Note, it’s a simple case of creating new variable names by prefixing or suffixing characters to the original column name specified by `{.col}`.\n\n------------------------------------------------------------------------\n\n## `mutate(across())` vs `summarise(across())`\n\nAs I mentioned at the outset, `across()` is most commonly used in conjunction with `mutate()`, but let's look at an example where we may want to use it with `summarise()`. Let's say we are interested in calculating the mean of each numeric column in the dataframe. We can do that as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  summarise(across(where(is.numeric), mean, na.rm = TRUE))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|      age| weight|   bmi| cholesterol|\n|--------:|------:|-----:|-----------:|\n| 49.33333|  76.86| 25.98|    5.766667|\n\n</div>\n:::\n:::\n\n\n<br>\n\nNote a common point of confusion:\n\n-   `mutate(across())` returns the **same number of rows** as in the original dataframe\\\n-   `summarise(across())` **reduces rows** (to a single row if no grouping structure is specified)\n\n`across()` is therefore applied to both functions in the same way, but with different intent.\n\n------------------------------------------------------------------------\n\n## Multiple Functions per Variable\n\nWhat if were interested in not only calculating the mean of each numeric column, but also the standard deviation and the number of observations in each column. Well, it's relatively easy to extend the above example by now applying *several* functions at once.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  summarise(across(where(is.numeric), list(mean = mean, \n                                           sd = sd,\n                                           n = ~ sum(!is.na(.))),\n                   .names = \"{.col}_{.fn}\"))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| age_mean|   age_sd| age_n| weight_mean| weight_sd| weight_n| bmi_mean|   bmi_sd| bmi_n| cholesterol_mean| cholesterol_sd| cholesterol_n|\n|--------:|--------:|-----:|-----------:|---------:|--------:|--------:|--------:|-----:|----------------:|--------------:|-------------:|\n| 49.33333| 14.57166|     3|       76.86|  4.405009|        3|    25.98| 2.158912|     3|         5.766667|      0.3082748|             3|\n\n</div>\n:::\n:::\n\n<br>\n\nWe can now specify `{.fn}` as a naming qualifier and append this to the original column name. This pattern is a stepping stone toward automated summary tables and reporting pipelines.\n\n------------------------------------------------------------------------\n\n## Advanced Example: Using `mutate(across())` with `map()`\n\nAre you ready for something more advanced (but also extremely powerful)? So far we have been dealing with a *single* dataframe, but we can also leverage the power of `across()` in simultaneous column manipulation over *multiple* dataframes using `map()`.\n\n### The Problem\n\nSuppose you have several datasets with the same structure assembled within a [list](https://www.r-bloggers.com/2024/10/the-ultimate-guide-to-creating-lists-in-r-from-basics-to-advanced-examples/) (a list is a convenient `R` object within which many other `R` objects can be stored - including dataframes). We can access a particular object within a list with the `$` operator, much like we access the columns of a dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatasets <- list(raw   = df, \n                 clean = df,\n                 sens  = df)\n\ndatasets$raw\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|   bmi| cholesterol|\n|:--|---:|------:|-----:|-----------:|\n|1  |  34|  72.46| 23.66|        5.42|\n|2  |  51|  81.27| 27.93|        6.01|\n|3  |  63|  76.85| 26.35|        5.87|\n\n</div>\n:::\n\n```{.r .cell-code}\ndatasets$clean\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|   bmi| cholesterol|\n|:--|---:|------:|-----:|-----------:|\n|1  |  34|  72.46| 23.66|        5.42|\n|2  |  51|  81.27| 27.93|        6.01|\n|3  |  63|  76.85| 26.35|        5.87|\n\n</div>\n:::\n\n```{.r .cell-code}\ndatasets$sens\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|   bmi| cholesterol|\n|:--|---:|------:|-----:|-----------:|\n|1  |  34|  72.46| 23.66|        5.42|\n|2  |  51|  81.27| 27.93|        6.01|\n|3  |  63|  76.85| 26.35|        5.87|\n\n</div>\n:::\n:::\n\n<br>\n\nNow, suppose you want to apply the **same transformation** to all of them.\n\n------------------------------------------------------------------------\n\n### The Naïve Way\n\n``` r\ndf_raw   <- df_raw   |>  mutate(...)\ndf_clean <- df_clean |>  mutate(...)\ndf_sens  <- df_sens  |>  mutate(...)\n```\n\nIn this approach we go through and re-apply the same code to each dataframe but this can become difficult to maintain and easy to get wrong.\n\n------------------------------------------------------------------------\n\n### The Better Way: `map()` + `mutate(across())`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatasets <- datasets |> \n  map(~ .x |> \n    mutate(across(where(is.numeric), round, 1)))\n\ndatasets$raw\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|  bmi| cholesterol|\n|:--|---:|------:|----:|-----------:|\n|1  |  34|   72.5| 23.7|         5.4|\n|2  |  51|   81.3| 27.9|         6.0|\n|3  |  63|   76.8| 26.4|         5.9|\n\n</div>\n:::\n\n```{.r .cell-code}\ndatasets$clean\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|  bmi| cholesterol|\n|:--|---:|------:|----:|-----------:|\n|1  |  34|   72.5| 23.7|         5.4|\n|2  |  51|   81.3| 27.9|         6.0|\n|3  |  63|   76.8| 26.4|         5.9|\n\n</div>\n:::\n\n```{.r .cell-code}\ndatasets$sens\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|  bmi| cholesterol|\n|:--|---:|------:|----:|-----------:|\n|1  |  34|   72.5| 23.7|         5.4|\n|2  |  51|   81.3| 27.9|         6.0|\n|3  |  63|   76.8| 26.4|         5.9|\n\n</div>\n:::\n:::\n\n<br>\n\nIndeed, the more efficient way is to use `across()` within `mutate()` within `map()`.\n\nWe can read this as:\n\n> “For each dataset, mutate across numeric variables by rounding to 1 decimal place.”\n\nThis approach using `map()` ensures:\n\n-   identical logic across datasets\\\n-   changes happen in one place\\\n-   consistency is guaranteed\n\n------------------------------------------------------------------------\n\n### Another Example: Standardising Variables Across Datasets\n\nNow, let's take this further by extending the earlier example of creating new variables, not just within a *single* dataframe, but across *multiple* dataframes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatasets <- datasets |> \n  map(~ .x |> \n    mutate(across(c(age, bmi, weight), scale, .names = \"{.col}_z\")))\n\ndatasets$raw\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|  bmi| cholesterol|      age_z|      bmi_z|    weight_z|\n|:--|---:|------:|----:|-----------:|----------:|----------:|-----------:|\n|1  |  34|   72.5| 23.7|         5.4| -1.0522707| -1.0806343| -0.99233882|\n|2  |  51|   81.3| 27.9|         6.0|  0.1143773|  0.8926979|  1.00748903|\n|3  |  63|   76.8| 26.4|         5.9|  0.9378935|  0.1879364| -0.01515021|\n\n</div>\n:::\n\n```{.r .cell-code}\ndatasets$clean\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|  bmi| cholesterol|      age_z|      bmi_z|    weight_z|\n|:--|---:|------:|----:|-----------:|----------:|----------:|-----------:|\n|1  |  34|   72.5| 23.7|         5.4| -1.0522707| -1.0806343| -0.99233882|\n|2  |  51|   81.3| 27.9|         6.0|  0.1143773|  0.8926979|  1.00748903|\n|3  |  63|   76.8| 26.4|         5.9|  0.9378935|  0.1879364| -0.01515021|\n\n</div>\n:::\n\n```{.r .cell-code}\ndatasets$sens\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|id | age| weight|  bmi| cholesterol|      age_z|      bmi_z|    weight_z|\n|:--|---:|------:|----:|-----------:|----------:|----------:|-----------:|\n|1  |  34|   72.5| 23.7|         5.4| -1.0522707| -1.0806343| -0.99233882|\n|2  |  51|   81.3| 27.9|         6.0|  0.1143773|  0.8926979|  1.00748903|\n|3  |  63|   76.8| 26.4|         5.9|  0.9378935|  0.1879364| -0.01515021|\n\n</div>\n:::\n:::\n\n\nYou can appreciate how much of a Swiss-army knife of data manipulation, `across()` can be become when used in conjunction with other `R` functions.\n\n------------------------------------------------------------------------\n\n## Final Thoughts and a Mental Model to Take Away\n\nWhenever you catch yourself thinking:\n\n> *“I’m doing the same thing to several variables…”*\n\nYou should immediately ask:\n\n> *“Can this be an `across()`?”*\n\nThat question alone will dramatically improve the quality of your R code.\n\nI hope you've found this programming tip helpful and I will see you again for more stats tips, next month.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}